Day1:

We build separate projects for different modules to properly organize and resuse our code.
The url consists of http://domain/controller/actionMethod/id. For each controller we can have many action methods
By default we are viewing the index action method under home controller. We can change this in program.cs.
In the controller class, action methods, return View(); will return the view with corresponding method name.
We can also specify the view we want to return by using return View("test"); which will return Test.cshtml. Not case sensitive.

ApplicationCore is the base project for the application
Entities in ApplicationCore will have objects that represent our DB tables
Models -> will have objects that represent your UI


Dapper is from StackOverflow

Services -> Domain/BUsiness Logic
e.g. GetJobById , Send Confirmation Email, Get All jobs

Controller => Services => Repositories(using EF Core or Dapper or ADO.NET ) -> Database

The interfaces in contracts under ApplicationCore will be implemented in Infrastructure


Day2:Dependency Injection

Older versions dotnet framework use : Njinject and autofac to use Denpendency injection
Now dotnet core has built-in Dependency Injection 
if you need to use advanced Dependency Injection(e.g. property Injection, method Injection, conditional Injection),
You still need to use Njinject and autofac(more popular)

Dependency injection is used to build loosly coupled code/application
to have your code maintainable and testable

ADO.NET ==> lower level API -> write lots of code
Dapper is micro ORM(object relational mapping) from StackOverflow. A bunch of extensions built on ADO.NET. 
Need to have an existing DB to use Dapper. (e.g. Northwind, AdventureWorks)
var employees = db.connection.execute <Employees> ("select * from Employee")
var employees = db.connection.execute <Employees>  ("usp_GetEmployee")

ORM => Object Relational Mapper
data access code simpler and write less code

Entity Framework -> Saves lots of time in creating/accessing the database
1. you can create complete DB using C# code with code-first appraoch , using concept called Migrations
2. you can access database and CRUD operations with just C#(LINQ) without writing any SQL
    Dapper/ADO.NET => SELECT * from Jobs where salary > 60000
    EF             => var employees = Employee.where(e => e.Salary > 60000).ToList(); 
                                        SELECT * from Jobs where salary > 60000
                      var employees = Employee.ToList().where(e => e.Salary > 60000).ToList(); 
                                        SELECT * from Jobs;
                                        then the filter > 60000 is gonna happen in memory
3. can map the data to C# Entities


Day3: create DB

Jobs => Jobs Info, ID, Title, Desc, JobCode
Candidate => Candidates
Submission => when candidates apply for the job [Candidate & JobId] => Unique constraints
JobStatusLookUp => Open, Closed, pending closed, postponed

step1: Install EF Core tools package globally
dotnet tool update --global dotnet-ef
dotnet tool install --global dotnet-ef



step2: First create an entity -> C# object that represents a table in the DB(Job.cs)


step3: Install required EF Core packages from Nuget in projects
    Microsoft.EntityFrameworkCore.SqlServer(in all three projects)
    Microsoft.EntityFrameworkCore.Design(in RecuitingWeb)


step4: In EF we have 2 very important classes
    DbContext => Represents your database
    DbSet => Represents your tables


step5: create the DbContext class and DbSet properties for the project(in Infrastructure)


step6: Create the Database ConnectionString, and establish that connectionString with the DbContext
        Keep Connection Strings if locally in the project in appsettings.json(most unsecure)
        user secrets(locally)
        Azure KeyVault
Run this to get name of device:
SELECT @@SERVERNAME

ConnectionString:
For Mac: "RecruitingDbConnection": "Server=localhost;Database=RecruitingDb;User=sa;Password=Antra300@@;TrustServerCertificate=True;"
For Windows: "RecruitingDbConnection": "Server=Abhilash-PC;Database=RecruitingDb;Integrated Security=True;TrustServerCertificate=True;"

step7: establish that connectionString with the DbContext using DI using the AddDbContext method

step8: Create your first Migration using dotnet ef tools commands
//-p (stands for property) tells which project to use
dotnet ef migrations add InitialMigration -p ../Infrastructure/Infrastructure.csproj 

some links:
https://learn.microsoft.com/en-us/ef/core/managing-schemas/migrations/?tabs=dotnet-core-cli


step9: always, check your migration file and see if it has things that you are trying to create


step10: Apply the migration using command
        dotnet ef database update 

step11: To model your database with rules, constraints etc we can do this in two ways
        1. Data Annotations(annotate constraints in the jobs entity and .net will convert it for you)
        2. Fluent API(if you have conflict rules for the same property, fluent API will take precedence)

    dotnet ef migrations add UpdateingJobsTable -p ../Infrastructure/Infrastructure.csproj
    dotnet ef database update
    To remove a migration:
    dotnet ef migrations remove -p ../Infrastructure/Infrastructure.csproj
always use code-first approach if you want to change the schemas! You can change data using sql, but not schemas


Create a foreign key:
https://learn.microsoft.com/en-us/ef/core/modeling/relationships?tabs=fluent-api%2Cfluent-api-simple-key%2Csimple-key



Day4: async

asynchronous programming -> 2002
async/await -> 2012 .net framework 4.5
to prevent thread starvation, and add scalability of our application
Thread Starvation: when you run out threads in the thread pool

public async Task<IActionResult> Index()
        {
            var jobs = await _jobService.GetAllJobs(); -> returning task. note:ToList() is synchronous method, we should use ToListAsync()
            return View();
            
        }

it will not add new threads, it will use existing threads properly

3 ways we cans send data from controller/action method to view

1. ViewBag
2. ViewData
most frequently used way:
3. ***Strongly Typed Model data***

<a asp-action="Create">Create New</a> ==> asp-action is tag helper(preferred one)
@Html.DisplayFor(modelItem => item.NumberOfPositions)  ==> this is html helper(Introduced in .net core)


Two ways to generate the view from controller/action:
1. the UI way(create a view using add -> View -> Razor View, see screenshot in notes in the recording folder)

2. using the terminal:

install the tool:
dotnet tool install -g dotnet-aspnet-codegenerator
dotnet-aspnet-codegenerator view Index list -m JobResponseModel  -outDir Views/jobs  -udl  -scripts
Index: View name
list: template
-m JobResponseModel: the model
-udl: use default layout


Day5: .Net Core Validation and Middleware

dotnet-aspnet-codegenerator view Create create -m JobRequestModel -outDir Views/jobs -udl -scripts

Validation happen on both client and server side, but server side is more important. Because we can make a POST
request without a client(like using POSTMAN)

form-control: uses bootstrap. bootstrap can help build responsive sites by adjusting to different devices

when you post the form, you can send the data with the name tags as key-value pairs!(So name and ID are both important)
model-binding: the data from the browser will be sent to the model and the object(model) properties will be mapped to the data
you can also map the values to parameters in the function arguments like:
public async Task<IActionResult> Create(JobRequestModel model, string Location) ==> you can map locaion to the parameter Location

public async Task<int> AddtAsync(T Entity)
        {
            _dbContext.Set<T>().Add(Entity);
            await _dbContext.SaveChangesAsync();
            return 1;
        }

in this method we have to write await _dbContext.SaveChangesAsync();
This is the line of code that actually make the changes!